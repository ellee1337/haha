-- ‚úÖ Fly + ESP Script with Simple Rayfield UI + Color Picker
-- ‚öôÔ∏è Works with any game that uses HumanoidRootPart
-- üñ±Ô∏è Press E to toggle fly

----------------------------------------------------
-- ü™ü Load Rayfield UI
----------------------------------------------------
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

----------------------------------------------------
-- üß† ESP System
----------------------------------------------------
local ESP = {
    Enabled = false,
    Boxes = true,
    BoxShift = CFrame.new(0,-1.5,0),
    BoxSize = Vector3.new(4,6,0),
    Color = Color3.fromRGB(255, 170, 0),
    FaceCamera = false,
    Names = true,
    TeamColor = true,
    Thickness = 2,
    AttachShift = 1,
    TeamMates = true,
    Players = true,
    Objects = setmetatable({}, {__mode="kv"}),
    Overrides = {}
}

local cam = workspace.CurrentCamera
local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer

local function Draw(obj, props)
    local new = Drawing.new(obj)
    for i,v in pairs(props or {}) do new[i] = v end
    return new
end

local boxBase = {}
boxBase.__index = boxBase

function boxBase:Remove()
    ESP.Objects[self.Object] = nil
    for i,v in pairs(self.Components) do v.Visible = false v:Remove() end
end

function boxBase:Update()
    if not self.PrimaryPart then return self:Remove() end
    if not ESP.Enabled then
        for _,v in pairs(self.Components) do v.Visible = false end
        return
    end

    local color = ESP.Color
    local cf = self.PrimaryPart.CFrame
    local size = self.Size
    local locs = {
        TopLeft = cf * ESP.BoxShift * CFrame.new(size.X/2,size.Y/2,0),
        TopRight = cf * ESP.BoxShift * CFrame.new(-size.X/2,size.Y/2,0),
        BottomLeft = cf * ESP.BoxShift * CFrame.new(size.X/2,-size.Y/2,0),
        BottomRight = cf * ESP.BoxShift * CFrame.new(-size.X/2,-size.Y/2,0),
        TagPos = cf * ESP.BoxShift * CFrame.new(0,size.Y/2,0)
    }

    local TopLeft, Vis1 = cam:WorldToViewportPoint(locs.TopLeft.p)
    local TopRight, Vis2 = cam:WorldToViewportPoint(locs.TopRight.p)
    local BottomLeft, Vis3 = cam:WorldToViewportPoint(locs.BottomLeft.p)
    local BottomRight, Vis4 = cam:WorldToViewportPoint(locs.BottomRight.p)
    local TagPos, Vis5 = cam:WorldToViewportPoint(locs.TagPos.p)

    if Vis1 or Vis2 or Vis3 or Vis4 then
        if ESP.Boxes and self.Components.Quad then
            self.Components.Quad.Visible = true
            self.Components.Quad.PointA = Vector2.new(TopRight.X, TopRight.Y)
            self.Components.Quad.PointB = Vector2.new(TopLeft.X, TopLeft.Y)
            self.Components.Quad.PointC = Vector2.new(BottomLeft.X, BottomLeft.Y)
            self.Components.Quad.PointD = Vector2.new(BottomRight.X, BottomRight.Y)
            self.Components.Quad.Color = color
        else
            self.Components.Quad.Visible = false
        end

        if ESP.Names and self.Components.Name then
            self.Components.Name.Visible = true
            self.Components.Name.Position = Vector2.new(TagPos.X, TagPos.Y)
            self.Components.Name.Text = self.Name
            self.Components.Name.Color = color
        else
            self.Components.Name.Visible = false
        end
    else
        for _,v in pairs(self.Components) do v.Visible = false end
    end
end

function ESP:Add(obj, options)
    local box = setmetatable({
        Name = options.Name or obj.Name,
        Type = "Box",
        Size = options.Size or self.BoxSize,
        Object = obj,
        Player = options.Player or plrs:GetPlayerFromCharacter(obj),
        PrimaryPart = options.PrimaryPart or obj:FindFirstChild("HumanoidRootPart"),
        Components = {}
    }, boxBase)

    box.Components["Quad"] = Draw("Quad", {
        Thickness = self.Thickness,
        Color = self.Color,
        Transparency = 1,
        Filled = false,
        Visible = false
    })

    box.Components["Name"] = Draw("Text", {
        Text = box.Name,
        Color = self.Color,
        Center = true,
        Outline = true,
        Size = 18,
        Visible = false
    })

    self.Objects[obj] = box
    return box
end

local function CharAdded(char)
    local p = plrs:GetPlayerFromCharacter(char)
    if p and p ~= plr then
        local hrp = char:WaitForChild("HumanoidRootPart", 10)
        if hrp then
            ESP:Add(char, {Name = p.Name, Player = p, PrimaryPart = hrp})
        end
    end
end

for _,p in pairs(plrs:GetPlayers()) do
    if p ~= plr and p.Character then CharAdded(p.Character) end
    p.CharacterAdded:Connect(CharAdded)
end

game:GetService("RunService").RenderStepped:Connect(function()
    for _,v in pairs(ESP.Objects) do
        v:Update()
    end
end)

----------------------------------------------------
-- ‚úàÔ∏è Fly Script
----------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local flying = false
local speed = 50
local bodyGyro, bodyVel

local function Fly()
    local char = plr.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    local hrp = char.HumanoidRootPart

    bodyGyro = Instance.new("BodyGyro", hrp)
    bodyGyro.P = 9e4
    bodyGyro.MaxTorque = Vector3.new(9e9,9e9,9e9)
    bodyGyro.CFrame = hrp.CFrame

    bodyVel = Instance.new("BodyVelocity", hrp)
    bodyVel.Velocity = Vector3.zero
    bodyVel.MaxForce = Vector3.new(9e9,9e9,9e9)

    while flying and task.wait() do
        local camCF = workspace.CurrentCamera.CFrame
        local moveDir = Vector3.zero

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir += camCF.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir -= camCF.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir -= camCF.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir += camCF.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveDir += Vector3.yAxis end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveDir -= Vector3.yAxis end

        bodyVel.Velocity = moveDir * speed
        bodyGyro.CFrame = camCF
    end

    if bodyGyro then bodyGyro:Destroy() end
    if bodyVel then bodyVel:Destroy() end
end

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.E then
        flying = not flying
        if flying then
            Fly()
        end
    end
end)

----------------------------------------------------
-- üé® Rayfield UI Controls
----------------------------------------------------
local Window = Rayfield:CreateWindow({
    Name = "Fly + ESP Menu",
    LoadingTitle = "Fly & ESP",
    LoadingSubtitle = "Rayfield UI",
    ConfigurationSaving = {Enabled = false},
})

local ESPTab = Window:CreateTab("ESP Settings")

ESPTab:CreateToggle({
    Name = "ESP Enabled",
    CurrentValue = false,
    Callback = function(value)
        ESP.Enabled = value
    end
})

ESPTab:CreateToggle({
    Name = "Show Boxes",
    CurrentValue = true,
    Callback = function(value)
        ESP.Boxes = value
    end
})

ESPTab:CreateToggle({
    Name = "Show Names",
    CurrentValue = true,
    Callback = function(value)
        ESP.Names = value
    end
})

ESPTab:CreateColorPicker({
    Name = "ESP Color",
    Color = Color3.fromRGB(255, 170, 0),
    Callback = function(color)
        ESP.Color = color
    end
})
